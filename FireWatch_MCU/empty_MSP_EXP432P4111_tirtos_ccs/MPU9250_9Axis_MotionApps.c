#include <math.h>
#include "MPU9250.h"
#include "MPU9250_9Axis_MotionApps.h"
#include "IMU_driver.h"

/*
const float magnet_offset[3] = {0.22968,
                                0.10339,
                                -0.49622};

const float magnet_matrix[6] = {0.90942,
                                0.0017346,
                                0.13274,
                                1.05740,
                                -0.025737,
                                1.05992};
*/
/* ================================================================================================ *
 | Default MotionApps v4.1 48-byte FIFO packet structure:                                           |
 |                                                                                                  |
 | [QUAT W][      ][QUAT X][      ][QUAT Y][      ][QUAT Z][      ][GYRO X][      ][GYRO Y][      ] |
 |   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  |
 |                                                                                                  |
 | [GYRO Z][      ][MAG X ][MAG Y ][MAG Z ][ACC X ][      ][ACC Y ][      ][ACC Z ][      ][      ] |
 |  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  |
 * ================================================================================================ */

const unsigned char dmpMemory[MPU9250_DMP_CODE_SIZE] = {
    // bank 0, 256 bytes
    0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
    0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
    0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
    0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,

    // bank 1, 256 bytes
    0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
    0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
    0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
    0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,
    
    // bank 2, 256 bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x78, 0xA2,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // bank 3, 256 bytes
    0xD8, 0xDC, 0xF4, 0xD8, 0xB9, 0xAB, 0xF3, 0xF8, 0xFA, 0xF1, 0xBA, 0xA2, 0xDE, 0xB2, 0xB8, 0xB4,
    0xA8, 0x81, 0x98, 0xF7, 0x4A, 0x90, 0x7F, 0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA,
    0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2, 0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80,
    0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF, 0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0,
    0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C, 0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1,
    0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1, 0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3,
    0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01, 0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88,
    0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80, 0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF,
    0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89,
    0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80, 0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9,
    0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E, 0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A,
    0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9, 0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11,
    0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55,
    0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xF0, 0x00, 0x28, 0x50, 0xF5, 0xBA, 0xAD, 0x8F, 0x9F, 0x28, 0x54,
    0x7C, 0xB9, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xDB, 0xB2, 0xB6, 0x8E, 0x9D,
    0xAE, 0xF5, 0x60, 0x68, 0x70, 0xB1, 0xB5, 0xF1, 0xDA, 0xA6, 0xDF, 0xD9, 0xA6, 0xFA, 0xA3, 0x86,
    
    // bank 4, 256 bytes
    0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
    0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,
    0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
    0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
    0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
    0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
    0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
    0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
    0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
    0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
    0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
    0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
    
    // bank 5, 256 bytes
    0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
    0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,
    0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
    0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
    0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
    0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
    0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
    0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
    0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
    0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
    0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0x97, 0x86,
    0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97, 0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40,
    0xB9, 0xA3, 0x8A, 0xC3, 0xC5, 0xC7, 0x9A, 0xA3, 0x28, 0x50, 0x78, 0xF1, 0xB5, 0x93, 0x01, 0xD9,
    0xDF, 0xDF, 0xDF, 0xD8, 0xB8, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04, 0x28, 0x51, 0x79, 0x1D, 0x30,
    0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78, 0x78, 0x9B, 0xF1, 0x1A, 0xB0,
    0xF0, 0xB1, 0x83, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0xB0, 0x8B, 0x29, 0x51, 0x79, 0xB1, 0x83, 0x24,

    // bank 6, 256 bytes
    0x70, 0x59, 0xB0, 0x8B, 0x20, 0x58, 0x71, 0xB1, 0x83, 0x44, 0x69, 0x38, 0xB0, 0x8B, 0x39, 0x40,
    0x68, 0xB1, 0x83, 0x64, 0x48, 0x31, 0xB0, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71,
    0x58, 0x44, 0x68, 0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0,
    0x8C, 0xA8, 0x04, 0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02,
    0x26, 0x46, 0x66, 0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38,
    0x64, 0x48, 0x31, 0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19,
    0x31, 0x48, 0x60, 0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86,
    0xA8, 0x6E, 0x76, 0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A,
    0x6E, 0x8A, 0x56, 0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E,
    0x9D, 0xB8, 0xAD, 0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55,
    0x7D, 0x81, 0x91, 0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D,
    0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51,
    0xD9, 0x04, 0xAE, 0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19,
    0x81, 0xAD, 0xD9, 0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9,
    0xAD, 0xAD, 0xAD, 0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76,
    0xF3, 0xAC, 0x2E, 0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC,
    
    // bank 7, 170 bytes (remainder)
    0x30, 0x18, 0xA8, 0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24,
    0xF2, 0xB0, 0x89, 0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9,
    0xD8, 0xD8, 0x79, 0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D,
    0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D,
    0x80, 0x25, 0xDA, 0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34,
    0x3C, 0xF3, 0xAB, 0x8B, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xB0, 0x87, 0x9C, 0xB9,
    0xA3, 0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3,
    0xA3, 0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
    0xA3, 0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3,
    0xA3, 0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3,
    0xDC, 0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
};

const unsigned char dmpConfig[MPU9250_DMP_CONFIG_SIZE] = {
//  BANK    OFFSET  LENGTH  [DATA]
    0x02,   0xEC,   0x04,   0x00, 0x47, 0x7D, 0x1A,   // ?
    0x03,   0x82,   0x03,   0x4C, 0xCD, 0x6C,         // FCFG_1 inv_set_gyro_calibration
    0x03,   0xB2,   0x03,   0x36, 0x56, 0x76,         // FCFG_3 inv_set_gyro_calibration
    0x00,   0x68,   0x04,   0x02, 0xCA, 0xE3, 0x09,   // D_0_104 inv_set_gyro_calibration
    0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,   // D_1_152 inv_set_accel_calibration
    0x03,   0x86,   0x03,   0x0C, 0xC9, 0x2C,         // FCFG_2 inv_set_accel_calibration
    0x03,   0x90,   0x03,   0x26, 0x46, 0x66,         //   (continued)...FCFG_2 inv_set_accel_calibration
    0x00,   0x6C,   0x02,   0x40, 0x00,               // D_0_108 inv_set_accel_calibration

    0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_00 inv_set_compass_calibration
    0x02,   0x44,   0x04,   0x40, 0x00, 0x00, 0x00,   // CPASS_MTX_01
    0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_02
    0x02,   0x4C,   0x04,   0x40, 0x00, 0x00, 0x00,   // CPASS_MTX_10
    0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_11
    0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_12
    0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_20
    0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_21
    0x02,   0xBC,   0x04,   0xC0, 0x00, 0x00, 0x00,   // CPASS_MTX_22

    0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,   // D_1_236 inv_apply_endian_accel
    0x03,   0x86,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_mpu_sensors
    0x04,   0x22,   0x03,   0x0D, 0x35, 0x5D,         // CFG_MOTION_BIAS inv_turn_on_bias_from_no_motion
    0x00,   0xA3,   0x01,   0x00,                     // ?
    0x04,   0x29,   0x04,   0x87, 0x2D, 0x35, 0x3D,   // FCFG_5 inv_set_bias_update
    0x07,   0x62,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38, // CFG_8 inv_send_quaternion
    0x07,   0x9F,   0x01,   0x30,                     // CFG_16 inv_set_footer
    0x07,   0x67,   0x01,   0x9A,                     // CFG_GYRO_SOURCE inv_send_gyro
    0x07,   0x68,   0x04,   0xF1, 0x28, 0x30, 0x38,   // CFG_9 inv_send_gyro -> inv_construct3_fifo
    0x07,   0x62,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38, // ?
    0x02,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,   // ?
    0x07,   0x83,   0x06,   0xC2, 0xCA, 0xC4, 0xA3, 0xA3, 0xA3, // ?
                 // SPECIAL 0x01 = enable interrupts
    0x00,   0x00,   0x00,   0x01, // SET INT_ENABLE, SPECIAL INSTRUCTION
    0x07,   0xA7,   0x01,   0xFE,                     // ?
    0x07,   0x62,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38, // ?
    0x07,   0x67,   0x01,   0x9A,                     // ?
    0x07,   0x68,   0x04,   0xF1, 0x28, 0x30, 0x38,   // CFG_12 inv_send_accel -> inv_construct3_fifo
    0x07,   0x8D,   0x04,   0xF1, 0x28, 0x30, 0x38,   // ??? CFG_12 inv_send_mag -> inv_construct3_fifo
    0x02,   0x16,   0x02,   0x00, 0x01                // D_0_22 inv_set_fifo_rate

    // This very last number is the FIFO rate.
    // 0x01 is 100Hz. Going faster than 100Hz (0x00=200Hz) tends to result in very noisy output.
    // DMP output frequency is calculated easily using this equation: (200Hz / (1 + value))
};

const unsigned char dmpUpdates[MPU9250_DMP_UPDATES_SIZE] = {
    0x01,   0xB2,   0x02,   0xFF, 0xF5,
    0x01,   0x90,   0x04,   0x0A, 0x0D, 0x97, 0xC0,
    0x00,   0xA3,   0x01,   0x00,
    0x04,   0x29,   0x04,   0x87, 0x2D, 0x35, 0x3D,
    0x01,   0x6A,   0x02,   0x06, 0x00,
    0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
    0x02,   0x60,   0x0C,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01,   0x08,   0x02,   0x01, 0x20,
    0x01,   0x0A,   0x02,   0x00, 0x4E,
    0x01,   0x02,   0x02,   0xFE, 0xB3,
    0x02,   0x6C,   0x04,   0x00, 0x00, 0x00, 0x00, // READ
    0x02,   0x6C,   0x04,   0xFA, 0xFE, 0x00, 0x00,
    0x02,   0x60,   0x0C,   0xFF, 0xFF, 0xCB, 0x4D, 0x00, 0x01, 0x08, 0xC1, 0xFF, 0xFF, 0xBC, 0x2C,
    0x02,   0xF4,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0xF8,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0xFC,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
    0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00
};

unsigned char mpu_dmpInitialize() {
	char xgOffset, ygOffset, zgOffset;
	unsigned char temp;
	unsigned char dmpUpdate[16] = {0};
	unsigned char j;
    unsigned int pos = 0;
	unsigned char fifoCount;
	unsigned char fifoBuffer[128];

    mpu_reset();
    delay_ms(30); // wait after reset

    // disable sleep mode
    mpu_setSleepEnabled(false);

    // get MPU hardware revision
    writeRegister(MPU9250_RA_BANK_SEL, 0x70);
    mpu_setMemoryStartAddress(0x06);
    mpu_setMemoryBank(0);

    // get X/Y/Z gyro offsets
    xgOffset = mpu_getXGyroOffset();
    ygOffset = mpu_getYGyroOffset();
    zgOffset = mpu_getZGyroOffset();
    
    readRegister(MPU9250_RA_USER_CTRL, &temp);
    
    //Enabling interrupt latch, clear on any read
    writeRegister(MPU9250_RA_INT_PIN_CFG, 0x32);

    //setI2CBypassEnabled(true);

    //mag -> setMode(0);
    writeRegister(MPU9250_RA_I2C_SLV2_ADDR, 0x0C);
    writeRegister(MPU9250_RA_I2C_SLV2_REG, 0x0A);
    writeRegister(MPU9250_RA_I2C_SLV2_DO, 0x00); // Power down magnetometer
    writeRegister(MPU9250_RA_I2C_SLV2_CTRL, 0x80);
    delay_ms(10);

    // load DMP code into memory banks
    if (mpu_writeProgMemoryBlock(dmpMemory, MPU9250_DMP_CODE_SIZE, 0, 0, 1)) {

        // write DMP configuration
        if (mpu_writeProgDMPConfigurationSet(dmpConfig, MPU9250_DMP_CONFIG_SIZE)) {	
			
            //Setting DMP and FIFO_OFLOW interrupts enabled...
            mpu_setIntEnabled(0x12);

            //Setting sample rate to 200Hz...
            mpu_setRate(4); // 1khz / (1 + 4) = 200 Hz

            //Setting clock source to Z Gyro...
            mpu_setClockSource(MPU9250_CLOCK_PLL_ZGYRO);

            //Setting DLPF bandwidth to 41Hz...
            mpu_setDLPFMode(MPU9250_DLPF_BW_41);

            //Setting gyro sensitivity to +/- 1000 deg/sec...
            mpu_setFullScaleGyroRange(MPU9250_GYRO_FS_2000);

            //Setting DMP configuration bytes...
            mpu_setDMPConfig1(0x03);
            mpu_setDMPConfig2(0x00);

            //Clearing OTP Bank flag...
            //mpu_setOTPBankValid(false);

            //Setting X/Y/Z gyro offsets to previous values...
            mpu_setXGyroOffset(xgOffset);
            mpu_setYGyroOffset(ygOffset);
            mpu_setZGyroOffset(zgOffset);

            //Writing final memory update 1/19
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);

            //Writing final memory update 2/19
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);

            //Resetting FIFO...
            mpu_resetFIFO();

            //Reading FIFO count...
            fifoCount = mpu_getFIFOCount();

            //Writing final memory update 3/19
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);

            //Writing final memory update 4/19
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);

            //Disabling all standby flags...
            writeRegister(MPU9250_RA_PWR_MGMT_2, 0x00);

            //Setting accelerometer sensitivity to +/- 2g...
            writeRegister(MPU9250_RA_ACCEL_CONFIG, 0x00);
  			//writeRegister(MPU9250_RA_ACCEL_CONFIG2, 0x02);

            //Setting motion detection threshold to 2...
            //mpu_setMotionDetectionThreshold(2);

            //Setting zero-motion detection threshold to 156...
            //mpu_setZeroMotionDetectionThreshold(156);

            //Setting motion detection duration to 80...
            //mpu_setMotionDetectionDuration(80);

            //Setting zero-motion detection duration to 0...
            //mpu_setZeroMotionDetectionDuration(0);

            //Setting AK8975 to single measurement mode...
            writeRegister(MPU9250_RA_I2C_SLV2_DO, 0x01); // Power down magnetometer
	        writeRegister(MPU9250_RA_I2C_SLV2_CTRL, 0x81);

            // setup AK8975 (0x0C) as Slave 0 in read mode
            writeRegister(MPU9250_RA_I2C_SLV0_ADDR, 0x8C);
            writeRegister(MPU9250_RA_I2C_SLV0_REG,  0x01);
            writeRegister(MPU9250_RA_I2C_SLV0_CTRL, 0xDA);

            // setup AK8975 (0x0C) as Slave 2 in write mode
            writeRegister(MPU9250_RA_I2C_SLV2_CTRL, 0x81);
            writeRegister(MPU9250_RA_I2C_SLV2_DO,   0x01);

            // setup I2C timing/delay control
            writeRegister(MPU9250_RA_I2C_SLV4_CTRL, 0x0F);
            writeRegister(MPU9250_RA_I2C_MST_DELAY_CTRL, 0x05);

            // enable interrupts
            writeRegister(MPU9250_RA_INT_PIN_CFG, 0x00);

            // enable I2C master mode and reset DMP/FIFO
            //Enabling I2C master mode...
            writeRegister(MPU9250_RA_USER_CTRL, 0x20);
            //Resetting FIFO...
            writeRegister(MPU9250_RA_USER_CTRL, 0x24);
            //Rewriting I2C master mode enabled 
            writeRegister(MPU9250_RA_USER_CTRL, 0x20);
            //Enabling and resetting DMP/FIFO...
            writeRegister(MPU9250_RA_USER_CTRL, 0xE8);
			
            //Writing final memory update 5/19
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);
            //Writing final memory update 6/19
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);
            //Writing final memory update 7/19
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);
            //Writing final memory update 8/19
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);
            //Writing final memory update 9/19 
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);
            //Writing final memory update 10/19 
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);
            //Writing final memory update 11/19 
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);
            
            //Reading final memory update 12/19 
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_readMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

            //Writing final memory update 13/19 
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);
            //Writing final memory update 14/19 
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);
            //Writing final memory update 15/19 
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);
            //Writing final memory update 16/19 
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);
            //Writing final memory update 17/19 
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);
			
            //Waiting for FIRO count >= 46...
            while ((fifoCount = mpu_getFIFOCount()) < 46); 
            //Reading FIFO...
            mpu_getFIFOBytes(fifoBuffer, fifoCount); // safeguard only 128 bytes
            //Reading interrupt status...
            mpu_getIntStatus();
            //Writing final memory update 18/19 
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);
			
            //Waiting for FIRO count >= 48
            while ((fifoCount = mpu_getFIFOCount()) < 48);
            //Reading FIFO...
            mpu_getFIFOBytes(fifoBuffer, fifoCount); // safeguard only 128 bytes
            //Reading interrupt status...
            mpu_getIntStatus();
            //Waiting for FIRO count >= 48...
            while ((fifoCount = mpu_getFIFOCount()) < 48);
            //Reading FIFO...
            mpu_getFIFOBytes(fifoBuffer, fifoCount); // safeguard only 128 bytes
            //Reading interrupt status...
            mpu_getIntStatus();

            //Writing final memory update 19/19 
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
                dmpUpdate[j] = *((unsigned char *)(dmpUpdates + pos));
            mpu_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1], 1, 0);

            //Disabling DMP (you turn it on later)...
            mpu_setDMPEnabled(false);

            //Resetting FIFO and clearing INT status one last time...
            mpu_resetFIFO();
            mpu_getIntStatus();

        } else return 2; // configuration block loading failed
    } else return 1; // main binary block loading failed
    return 0; // success
}

char mpu_dmpPacketAvailable() {
    return mpu_getFIFOCount() >= 48;
}

void mpu_dmpGetQuaternion(const unsigned char* packet, float* data) {
    // TODO: accommodate different arrangements of sent output (ONLY default supported now)
    //if (packet == 0) packet = dmpPacketBuffer;
    int16_t q0, q1, q2, q3;
    q0 = (((unsigned int)packet[0]) << 8) | packet[1];
    q1 = (((unsigned int)packet[4]) << 8) | packet[5];
    q2 = (((unsigned int)packet[8]) << 8) | packet[9];
    q3 = (((unsigned int)packet[12]) << 8) | packet[13];

    data[0] = (float)(q0) / quat_res;
    data[1] = (float)(q1) / quat_res;
    data[2] = (float)(q2) / quat_res;
    data[3] = (float)(q3) / quat_res;
}

void mpu_dmpGetGyro(const unsigned char* packet, float* data) {
    // TODO: accommodate different arrangements of sent output (ONLY default supported now)
    //if (packet == 0) packet = dmpPacketBuffer;
    int16_t gx, gy, gz;
    gx = (((unsigned int)packet[16]) << 8) | packet[17];
    gy = (((unsigned int)packet[20]) << 8) | packet[21];
    gz = (((unsigned int)packet[24]) << 8) | packet[25];

    data[0] = (float)(gx) / gyro_res;
    data[1] = (float)(gy) / gyro_res;
    data[2] = (float)(gz) / gyro_res;
}

void mpu_dmpGetMag(const unsigned char* packet, float* data) {
    // TODO: accommodate different arrangements of sent output (ONLY default supported now)
    //if (packet == 0) packet = dmpPacketBuffer;
    int16_t mx, my, mz;
    mx = (((unsigned int)packet[28]) << 8) | packet[29];
    my = (((unsigned int)packet[30]) << 8) | packet[31];
    mz = (((unsigned int)packet[32]) << 8) | packet[33];

    // read data and change axis
    data[1] = (float)(mx) / mag_res; // swap x axis and y axis
    data[0] = (float)(my) / mag_res; // swap x axis and y axis
    data[2] = (float)(-1 * mz) / mag_res; // reverse z axis
}

float mpu_dmpGetMagAngle(float* q, float* mag, float* mag_ref) {
    //if (packet == 0) packet = dmpPacketBuffer;
    float sin_yaw, cos_yaw, sin_pitch, cos_pitch, sin_roll, cos_roll;
    float grav[3], mag_angle;
    float M_hori = mag_ref[0];
    float M_verti = mag_ref[1];
    grav[0] = 2.0f*(q[1]*q[3] - q[0]*q[2]);
    grav[1] = 2.0f*(q[0]*q[1] + q[2]*q[3]);
    grav[2] = 2.0f*(q[0]*q[0] + q[3]*q[3]) - 1.0f;
    sin_pitch = grav[0];
    cos_pitch = sqrt(1 - sin_pitch * sin_pitch);
    sin_roll = -grav[1] / cos_pitch;
    cos_roll = -grav[2] / cos_pitch;
    sin_yaw = (mag[0] + grav[0] * M_verti) / (M_hori * cos_pitch);
    cos_yaw = ((mag[1] + grav[1] * M_verti) / M_hori - sin_roll * sin_pitch * sin_yaw) / cos_roll;
    mag_angle = -1 * atan2(sin_yaw, cos_yaw);

    return mag_angle;
}

void mpu_dmpGetLinearAccel(signed short* accel, float* q, float* data) {
    // TODO: accommodate different arrangements of sent output (ONLY default supported now)
    //if (packet == 0) packet = dmpPacketBuffer;
    int16_t ax, ay, az;
    float acx, acy, acz;
    ax = accel[0];
    ay = accel[1];
    az = accel[2];
    //20-07-21 Long edit accel alignment: AccX = Ay, accY = -Ax, accZ = -Az
    acx = (float)(ax) / acc_res;
    acy = (float)(ay) / acc_res;
    acz = (float)(az) / acc_res;
    //subtract gravitaional acceleration from the frame
    data[0] = acx - 2.0f*(q[1]*q[3] - q[0]*q[2]);
    data[1] = acy - 2.0f*(q[0]*q[1] + q[2]*q[3]);
    data[2] = acz - (2.0f*(q[0]*q[0] + q[3]*q[3])-1.0f);
    //data[0] = acx;
    //data[1] = acy;
    //data[2] = acz;

} 

void mpu_dmpGetRawAccel(const unsigned char* packet, float* data) {
    // TODO: accommodate different arrangements of sent output (ONLY default supported now)
    //if (packet == 0) packet = dmpPacketBuffer;
    int16_t ax, ay, az;
    //float acx, acy, acz;
    ax = (((unsigned int)packet[34]) << 8) | packet[35];
    ay = (((unsigned int)packet[38]) << 8) | packet[39];
    az = (((unsigned int)packet[42]) << 8) | packet[43];
    data[0] = (float)(ax);
    data[1] = (float)(ay);
    data[2] = (float)(az);

}
void mpu_dmpGetYawPitchRoll(float* q, float* rad) {
    // yaw: (about Z axis)
    rad[0] = atan2((q[1]*q[2]+q[0]*q[3]), q[0]*q[0] + q[1]*q[1] - 0.5f); //rad
    // pitch: (nose up/down, about Y axis)
    rad[1] = asin(2.0f*(q[0]*q[2]-q[1]*q[3]));
    // roll: (tilt left/right, about X axis)
    rad[2] = atan2((q[0]*q[1]+q[2]*q[3]), q[0]*q[0] + q[3]*q[3] - 0.5f);
}
void mpu_dmpGetYawPitchRollNew(float *q, float *rad)
{
    float t1, t2, t3;
    t1 = - q[1] * q[2] - q[0] * q[3];
    t2 = q[1] * q[1] + q[0] * q[0] - 0.5f;
    t3 = q[1] * q[3] - q[0] * q[2];
    rad[0] = -atan2(t1,t2);
    //
    rad[1] = atan2(t3,sqrt(t1 * t1 + t2 * t2));
    t2 = q[3] * q[3] + q[0] * q[0] - 0.5f;
    if (t2 < 0) {
        if (rad[1] >= 0)
            rad[1] = PI - rad[1];
        else
            rad[1] = -PI - rad[1];
    }
    t1 = q[2] * q[2] + q[0] * q[0] - 0.5f;
    t2 = - q[1] * q[2] + q[0] * q[3];
    t3 = - q[2] * q[3] - q[0] * q[1];

    rad[2] = atan2(q[3] * q[3] + q[0] * q[0] - 0.5f, t3) - PI/2;
    if(rad[2] >= PI/2)
    {
        rad[2] = PI - rad[2];
    }
    if(rad[2] <= -PI/2)
    {
        rad[2] = -PI - rad[2];
    }


}

void mpu_dmpGetLinearAccelInWorld(float* q, float* a) {
    float pw, px, py, pz;
	pw = 0.0f - q[1]*a[0] - q[2]*a[1] - q[3]*a[2];  // new w
    px = q[0]*a[0] + 0.0f + q[2]*a[2] - q[3]*a[1];  // new x
    py = q[0]*a[1] - q[1]*a[2] + 0.0f + q[3]*a[0];  // new y
    pz = q[0]*a[2] + q[1]*a[1] - q[2]*a[0] + 0.0f;  // new z

    a[0] = pw*(-q[1]) + px*q[0] + py*(-q[3]) - pz*(-q[2]);  // new x
    a[1] = pw*(-q[2]) - px*(-q[3]) + py*q[0] + pz*(-q[1]);  // new y
    a[2] = pw*(-q[3]) + px*(-q[2]) - py*(-q[1]) + pz*q[0];  // new z
}

void mpu_dmpGetLinearAccelInFrame(float bias, float* rad, float* a){
    float sinz, cosz, siny, cosy, sinx, cosx;
    float ax, ay, az;
    float temp_val = rad[0] - bias;
    if (temp_val > PI)
        temp_val -= 2 * PI;
    else if (temp_val < -PI)
        temp_val += 2 * PI;
    sinz = sin(temp_val);
    cosz = sqrt(1.0f - sinz * sinz);
    siny = sin(rad[1]);
    cosy = sqrt(1.0f - siny * siny);
    sinx = sin(rad[2]);
    cosx = sqrt(1.0f - sinx * sinx);

    ax = a[0];
    ay = a[1];
    az = a[2];

    a[0] = cosy * cosz * ax + (sinx * siny * cosz - cosx * sinz) * ay + (cosx * siny * cosz + sinx * sinz) * az;  // new x
    a[1] = cosy * sinz * ax + (sinx * siny * sinz + cosx * cosz) * ay + (cosx * siny * sinz - sinx * cosz) * az;  // new y
    a[2] = -siny * ax + sinx * cosy * ay + cosx * cosy * az;  // new z
}
